package main

import (
	"context"
	"log"
	"net"
	"sort"
	"time"

	"google.golang.org/grpc"
)

type Empty struct{}
type UnimplementedAdServiceServer struct{}

// AdServiceServer defines our service
type AdServiceServer struct {
	UnimplementedAdServiceServer
}

// AggregatedResult represents the aggregation result
type AggregatedResult struct {
	AdID      string
	Clicks    int
	Timestamp int64
}

// TopAdsRequest represents a request to fetch the top ads
type TopAdsRequest struct {
	AdCategory string
	Limit      int
}

// TopAdsResponse represents the response containing the top clicked ads
type TopAdsResponse struct {
	Ads []AggregatedResult
}

// ClickEvent represents a single click event
type ClickEvent struct {
	AdID      string
	UserID    string
	Timestamp int64
}

const PORT string = ":50051"

var clicksMap map[string]int

func main() {
	listener, err := net.Listen("tcp", PORT)
	if err != nil {
		log.Fatalf("Failed to listen: %v", err)
	}

	s := grpc.NewServer()
	RegisterAdServiceServer(s, NewAdServiceServer())

	log.Printf("server listening at %v", listener.Addr())
	if err := s.Serve(listener); err != nil {
		log.Fatalf("failed to server: %v", err)
	}
}

func NewAdServiceServer() *AdServiceServer {
	return &AdServiceServer{}
}

// Method registers the AdServiceServer with the gRPC server
func RegisterAdServiceServer(s *grpc.Server, srv *AdServiceServer) {
	// This is where you'd hook up server methods with the gRPC server.
	// Normally, this method is auto-generated by protoc but we'll simulate it here.
	log.Println("ad-service server registered.")
}

// GetTopAds returns the top 100 most clicked ads
func (s *AdServiceServer) GetTopAds(ctx context.Context, req *TopAdsRequest) (*TopAdsResponse, error) {
	// implement logic to sort and fetch top 100 ads
	ads := []AggregatedResult{
		{AdID: "ad_123", Clicks: 100, Timestamp: time.Now().Unix()},
		{AdID: "ad_456", Clicks: 200, Timestamp: time.Now().Add(-24 * time.Hour).Unix()},
		{AdID: "ad_789", Clicks: 150, Timestamp: time.Now().Add(-48 * time.Hour).Unix()},
	}
	sort.Slice(ads, func(i, j int) bool { return ads[i].Clicks > ads[j].Clicks })

	return &TopAdsResponse{Ads: ads}, nil
}

// RecordClick handles incoming click events
func (s *AdServiceServer) RecordClick(ctx context.Context, event *ClickEvent) (*Empty, error) {
	clicksMap[event.AdID] += 1
	return &Empty{}, nil
}
